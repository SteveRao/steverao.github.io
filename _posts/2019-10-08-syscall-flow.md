---
layout:     post
title:      "操作系统（三）：系统调用"
subtitle:   "系统调用简述"
date:       2019-10-08
author:     "ZihaoRao"
catalog: true
header-img: "img/in-post/bg/night-sky.jpg"
tags: 操作系统
---





### 总体概述
---
> This article is written in Chinese. If necessary, please consider using [Google Translate](http://translate.google.com/translate?hl=en&sl=auto&tl=en&u=https://steverao.github.io/2019/10/08/syscall-flow/)
>
> 对于普通用户来说，操作系统也许意味着 PC显示器上看到的五光十色界面，但对于软件开发人员来说，操作系统则代表着使用计算机硬件资源的宝库入口。那该如何利用操作系统来使用计算机资源呢？这就涉及到本文将介绍的操作系统为所有用户程序所提供的调用接口——系统调用。 
>
> **本文遵循[CC-BY-NC 4.0](https://creativecommons.org/licenses/by-nc/4.0/)开源分享协议，转载文章内容请注明出处。**                                                                                                                        





### 1 认识系统调用
---
&emsp;&emsp;对于**系统调用**一词维基百科给出的解释如下：

> 在计算机中，系统调用（system call），指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务，系统调用提供了用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行，如设备 I/O操作或者进程间通信。

&emsp;&emsp;维基百科的解释非常精炼。但为了更好的认识系统调用，我们还是将其与我们熟悉的本地调用进行对比解释。本地调用顾名思义就是用户程序调用用户本地编写的函数，通常情况下，调用一个普通自定义函数和调用系统调用在代码上没什么区别，但调用后所发生的故事却完全不同。

&emsp;&emsp;操作系统在**保护模式**下，处理器执行时分为**用户态**和**核心态**。用户程序执行时处于用户态，待调用的自定义函数与当前用户程序所执行代码都存放在用户态内存空间（即用户特权级段中）。在汇编指令中，通过 call或者 jmp指令就可以直接跳转到对应的本地调用代码段进行运行（相关基础详见[操作系统(二):内存管理](https://steverao.github.io/2019/10/05/memory-management-of-cpu/)）。

&emsp;&emsp;到这里，对操作系统演进不太熟悉的读者可能会产生疑惑，为什么不把那些系统调用所提供的计算机服务也像普通用户自定义函数一样存放在用户态（即设置成用户特权级），这样不就省去了“多余的”的系统调用了吗？其实这就需要了解操作系统为什么会有保护模式，处理器为什么会出现用户态和核心态（相关知识详见[操作系统(二):内存管理](https://steverao.github.io/2019/10/05/memory-management-of-cpu/)中从实模式到保护模式部分）。

&emsp;&emsp;所以对于一些重要的软硬件资源的调用只有操作系统程序有相关权限。而用户程序有时又需要利用相关系统资源哪该怎么办呢？正是基于这点，操作系统对于一些用户程序常用的计算机硬件服务通过**系统调用**这一接口形式为用户程序提供调用服务。系统调用与用户程序间关系见下图：

<div align="center"><img src="/img/in-post/content/os/syscall/kernel-syscall.png" width="50%"/><b>Figure 1：System Call</b></div>





### 2 系统调用执行过程
---
&emsp;&emsp;明白了系统调用概念，那在系统调用执行后，操作系统又是完成了哪些工作来为用户程序提供系统服务的呢？首先，通过一句话来概括系统调用执行过程就是：**执行系统调用让处理器从用户态转切换到内核态，然后，处理器在内核态执行相应的系统调用处理程序为用户程序提供相关的服务。**要执行系统调用首先要让处理器切换到内核态，在现代操作系统中，用户程序从用户态切换到内核态的唯一方法就是通过陷阱（也叫软中断）来实现（相关资料详见[操作系统(一):异常](https://steverao.github.io/2019/10/02/exception/)中陷阱部分）。用户程序调用系统调用，从请求到返回结果过程的详细步骤如下：

1. 应用程序通过调用 C库函数 API来间接调用其对应的系统调用（如上图Figure 1所示）；

2. 库函数API 将系统调用号作为参数存入处理器的某个特定寄存器中（32位处理器一般是 eax寄存器），然后通过陷阱（也叫软中断）使处理器从用户态切换到内核态；

3. 内核中执行的中断处理程序根据系统调用号，调用对应的内核函数（即系统调用）；

4. 系统调用完成相应功能后，将返回值存入传参的寄存器中，通过其返回到中断处理程序；

5. 中断处理程序执行结束到库函数 API中；

6. 库函数 API最后将寄存器中的返回值返回给应用程序;

   ​



### 3 系统调用实验
---
&emsp;&emsp;理解了上述对系统调用的介绍，最好的检验方式就是实际动手到操作系统内核中去亲自为内核添加一些系统调用去感受系统调用实现原理。正好实验楼提供了对应的[系统调用实验](https://www.shiyanlou.com/courses/115/learning/?id=569)。读者可以通过为 Linux 0.11操作系统内核添加两个自定义的系统调用并编译到内核中亲自感受一下如何实现系统调用。实验过程中如有问题可以参考[操作系统实验(三):系统调用](https://steverao.github.io/2019/10/17/syscall-lab/)。

​

### 4 小结
---
- 本文主要对操作系统中系统调用相关概念以及调用过程进行了一个总结，既是对相关概念的梳理也是为理解操作系统后续核心内容做准备。其中没有涉及太多的案例或实验内容。但对应的实验在其他文章中已经记录，上文也已提及，有兴趣的读者可以进行查看。另外，相关的案例在下一篇文章介绍 Linux 0.11进程调度相关函数源码中会有涉及，有兴趣的读者可在阅读完本文后查看相关文章来感受系统调用在这些操作系统核心主题上的应用。

  ​




### 参考资料
---
- [哈尔滨工业大学操作系统课程，李治军](https://www.bilibili.com/video/av17036347?from=search&seid=11186295937821986776)
- [操作系统原理与实践，李治军](https://www.shiyanlou.com/courses/115)
- [Linux内核完全注释，赵炯](https://book.douban.com/subject/1231236/)
- [深入理解计算机系统（第三版），Randal E.Bryant](https://book.douban.com/subject/26912767/)

