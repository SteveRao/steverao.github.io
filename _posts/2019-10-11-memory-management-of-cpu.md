---
layout:     post
title:      "操作系统（二）：处理器内存管理"
subtitle:   "x86处理器内存管理"
date:       2019-10-13
author:     "ZihaoRao"
catalog: true
header-img: "img/in-post/bg/night-sky.jpg"
tags: 操作系统
---





### 前言
---
> 处理器（Central Processing Unit, CPU）作为计算机系统中最核心的部件，为计算机实现了最重要的计算功能。然而，巧妇难为无米之炊，没有信息数据处理器什么也干不了！处理器是如何获取硬盘数据来为计算机系统提供计算服务的呢？其实现方式就是本文将要介绍的处理器内存管理机制。





### 1 内存寻址
---

&emsp;&emsp;在详细介绍处理器内存管理前，本节先来简单介绍一下计算机内存寻址方式，这既是计算机内存管理的基础也是后文理解实模式和保护模式等内容的前决条件（本文相关内容所涉及处理器默认为 x86系列）。

#### 1.1 寻址过程

&emsp;&emsp;在介绍具体的寻址方式前，首先来了解一下计算机处理器（Central Processing Unit, CPU）的寻址流程。计算机系统的主存被组织成一个由 M个连续字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address）。例如第一个字节地址为 0，接下来的字节地址为 1，再下一个为 2，依此类推。假设当前 CPU需执行一条指令，它读取从物理地址 4处开始的 4个字节。首先，CPU将指令中要开始读取的位置的**地址**通过地址总线，传递给内存，内存取出对应地址的数据再通过数据总线将其返回给 CPU。CPU收到数据后将其存放在对应的寄存器上便可开始对数据进行后续处理。以上就是 CPU的寻址流程。

#### 1.2 物理寻址

&emsp;&emsp;常见的寻址方式有两类——物理寻址和虚拟寻址，物理寻址（Physical Addressing）表示的是 CPU在程序中获得的地址就是内存中的真实地址，不需要进行任何处理通过地址总线传给内存，内存就可以直接访问并取出数据返回给 CPU。这种方式很直接，早期的 PC采用了这样一种寻址方式，并且诸如数字信号处理器，嵌入式微控制器以及 Cray超级计算机这样一些系统仍然采用这种寻址方式。

#### 1.3 虚拟寻址

&emsp;&emsp;物理寻址方式固然简单，但在当今复杂的计算机使用场景下，其存在一个致命问题。任何程序要运行首先都要被加载到内存中，采用物理寻址方式，意味着一段程序执行过程中的数据在内存中的存储位置都要按照该程序所规定地址来存储。然而内存作为宝贵的资源，很可能在该程序被加载进内存前，对应的内存空间早已被其他程序占据。所以大部分时候，程序的数据等信息都是当内存哪里有空闲就被存放在哪里，不可能是想存放在哪就放在哪！因此物理寻址无法满足当今计算机系统的寻址要求。现如今，计算机普遍采用的寻址方式为虚拟寻址（Virtual Addressing）。常见的虚拟寻址方式有分段和分页，下图表示 x86处理器虚拟寻址流程，后续章节将对其中的两种寻址过程进行详细说明。

<div align="center"><img src="/img/in-post/content/os/addressing-mode/simple-addressing-mode.png" width="80%"/><b>Figure 1：Virtual Addressing Mode </b></div>





### 2 从实模式到保护模式
---

#### 2.1 实模式与保护模式

&emsp;&emsp;谈起处理器的发展历史，不得不从 intel 8086这款古老而又经典的 x86架构处理器开始。它是 intel的第一款 16位处理器，之后的 32位或现今常见的 64位处理器都是在它的基础上设计研发的。

&emsp;&emsp;接下来，通过 intel 8086处理器的寻址方式来认识处理器的第一种运行模式——**实模式**（Real Mode）。intel 8086尽管作为一款 16位的处理器。但它有20根地址线。换句话说它提供的是 20位的物理地址，可访问 1MB内存（这样做原因很简单，就是为了扩大内存）。但在访问代码段时，如何通过 16位的段寄存器（Code Segment，CS）以及 16位的指令指针（Instruction Pointer，IP）构造出 20位的物理地址呢？原理也很简单，8086在形成物理地址时，先将段寄存器中的内容左移 4位，形成 20位的段地址，然后再同 16位的偏移地址相加，得到 20位的物理地址。通过上述方法构造的物理地址通过地址总线传输给内存就可获取对应地址的数据，以上寻址过程就是 8086处理器的实模式寻址（通过物理地址就可访问对应内存）。

&emsp;&emsp;实模式下的处理器寻址方式直接高效，但随着计算机应用的推广，仅仅只支持实模式的处理器上运行的操作系统安全性引起了大家的广泛关注。在这种模式下用户程序非常自由，可以根据目标地址跳转到计算机内存中的任意位置，当有恶意的用户程序想要从内存中获取内存中私密信息理论上是可行的。为了解决计算机数据泄露的隐患，从 intel 80286处理器开始，通过硬件方法为运行在其上的操作系统提供了**保护模式**运行机制，保护模式顾名思义，就是在提供了访存地址以后还需要验证调用进程是否有访问目标地址的权限。验证通过则可正常访存，否则访存操作被禁止。

#### 2.2 段选择符

&emsp;&emsp;为了实现处理器的保护模式，原先实模式下的分段软硬件结构肯定不再有效。为此，处理器设计了一系列新的软硬件结构来支持保护模式。首先要认识的第一个新结构是**段选择符**（或称段选择子），它相当于实模式下的段首地址在调用段前被存储在段寄存器中。在 16处理器中，它是段的一个 16位的唯一标识，见下图 1所示，它并不直接指向段，而是指向**段描述符表**中定义段的**段描述符**（下文将详细介绍）。段选择符中的 3个字段内容分别如下：

- **请求特权级 RPL**(Requested Privilege Level)

  它提供了段的保护信息，非常重要将在后文详细介绍。

- **表指示标志 TI**(Table Index)

  用来指出包含指定段描述符的段描述符表 GDT（Global Descriptor Table）或 LDT（Local Descriptor Table），当 TI=1时表示使用下文的索引值到 LDT中去搜索对应的段描述符，否则，到 GDT中去搜索。

- **索引值**(Index)

  该段的段描述符在对应的描述符表中的索引值。

  <div align="center"><img src="/img/in-post/content/os/addressing-mode/segment-selector.png" width="80%"/><b>Figure 2：Segment Selector</b></div>

#### 2.3 段描述符

&emsp;&emsp;保护模式下，段寄存器中存放的不是段基地址而是段选择符，那段的基地址存放在哪并如何才能获得呢？这就要说到保护模式下寻址模式中另一个非常重要的结构**段描述符**。它不仅存放着对应段的基地址，并且还包含了段的大小，访问权限和段的特权级等信息，为保护模式下对段的访问保护提供了硬件支持。其结构如下图所示：

<div align="center"><img src="/img/in-post/content/os/addressing-mode/segment-descriptor.png" width="80%"/><b>Figure 3：Segment Descriptor</b></div>

&emsp;&emsp;由上图可知，一个段描述符占 64位，其中基地址占 32位，其他段属性占另外 32位。本文仅需重点了解基地址和 DPL（Descriptor Privilege Level）这两个属性即可，其他属性有兴趣的读者可参考 《Linux内核完全注释》第四章相关内容。一个任务的段描述符存储在系统的段描述符表中，在操作系统运行过程中会建立两张段描述符表分别是全局描述符表（Global Descriptor Table，GDT）和本地描述符表（Local Descriptor Table，LDT）。由上文段选择器的位数可知，系统中总共的段描述符数量最多为 2^14次方，一般来说，GDT和 LDT各占一半都存储 2^13次方个段描述符。到这里也许会产生疑问，为什么要分两张表来存储？其实这还是为了把系统程序的段与用户应用程序的段进行分离，操作系统程序和一些全局任务的段在系统运行过程中是不需要修改并需要提供对全局可访问所以存储在 GDT中，而用户程序的段则存储在 LDT中，在每一次进程切换过程中都会切换 LDT中的数据。GDT和 LDT大致工作过程见下图：

<div align="center"><img src="/img/in-post/content/os/addressing-mode/gdt-ldt.png" width="80%"/><b>Figure 4：Segment Descriptor Table</b></div>

#### 2.4 保护环

&emsp;&emsp;有了以上相关概念的铺垫，接下来就可以来认识保护模式下最核心的概念**保护环**机制。保护模式下的处理器为段提供了四种保护级别来控制段的访问，如下图所示：

<div align="center"><img src="/img/in-post/content/os/addressing-mode/protection-ring.png" width="80%"/><b>Figure 5：Protection Ring</b></div>

&emsp;&emsp;由上图可知，处理器的 4级保护级别，分别是从 0级到 3级，数值越大，权限越小。当前处理器运行任务段的特权级为 0时，则表示处理器处于内核态。特权级为3时，处理器则处于用户态。接下来就通过上文已经讲述的 CPL的 DPL来认识，在保护模式下操作系统如何控制对段的访问。

&emsp;&emsp;当程序在访问一个段之前，处理器首先通过段选择符获取目标段的 DPL，然后判断当前程序特权级 CPL小于等于 DPL是否成立，成立则允许调用访问否则产生一个保护异常。判断过程如下图所示：(为了简单理解概念，可忽略图中的 RPL)

<div align="center"><img src="/img/in-post/content/os/addressing-mode/call-segment.png" width="80%"/><b>Figure 6：Call Segment</b></div>

&emsp;&emsp;以上就是保护模式下段间调用最简单的示意过程，尽管真实的判断过程并没有如上所述如此简单，会有一些如 RPL等等的额外判断规则（想了解更多细节可参考《Linux内核完全注解》第四章相关内容），但上述判断过程已经是保护模式下段访问保护最本质的思想，理解了它就对处理器的保护模式有了一个大致认识。






### 3 地址变换
---

&emsp;&emsp;任何完整的内存管理都包含两个关键部分：保护和地址变换。然而，很多地址变化技术在实现上已经提供了一系列的保护功能（如第二节保护环机制），所以内存管理中最核心的内容就是如何实现地址变化。本文接下来通过 x86处理器采用的两种最广泛使用的地址变换技术——分段和分页来进一步认识 x86处理器的内存管理实现。

#### 3.1 分段

&emsp;&emsp;分段（Segment）技术作为 x86系列处理器最早也是最基础和核心的虚拟寻址方式，其通过将程序按照组织形式分成一个或多个称为段的线性区域，对内存中数据对象的寻址通过采用段起始地址（即段地址）和一个段内偏移地址两部分组成。实模式下的分段方式非常的简单（上文已经说明），所以本节所讨论的分段默认指的就是保护模式下的分段技术（处理器为 32位）。

&emsp;&emsp;在 x86系列处理器中，段地址部分使用 16位的**段选择符**指定。其中 14位作为有效的选择位，可形成 2^14次方个段。段内偏移地址部分使用 32位的值来指定，即段内偏移范围为 0~4G。因此一个段的最大长度为 4G，通过以上16位的段基地址和 32位偏移地址即构成的一个 48位地址表示一个对象的逻辑地址（段基地址：段偏移）。有了第二节中提到的段选择符和段描述符相关概念后，对于保护模式下的分段寻址方式就非常容易理解了，其寻址过程如下图所示：

<div align="center"><img src="/img/in-post/content/os/addressing-mode/segment-addressing.png" width="80%"/><b>Figure 7：Segment Addressing </b></div>

#### 3.2 分页

&emsp;&emsp;分页机制作为 x86处理器中第二种虚拟寻址方式，其在分段的基础上，将段内的存储空间划分为固定大小的页面（x86采用默认为4K大小）。页面不仅可存储在内存中还可放在硬盘上，操作系统通过维护一个页目录和一些页表来留意这些页面。当程序试图访问线性地址空间中的一个地址位置时，处理器就使用页目录和页表把线性地址转换成一个物理地址，然后在内存中执行需要的读写操作。接下来通过一张图来说明在 x86系列处理器中分页与分段的关系以及分页寻址的详细过程：

<div align="center"><img src="/img/in-post/content/os/addressing-mode/addressing-mode.png" width="80%"/><b>Figure 8：x86 Addressing Mode</b></div>

&emsp;&emsp;如上图所示，在 x86处理器中分段寻址作为最基本和默认的寻址方式，而分页寻址是在分段寻址基础上扩展而来的一种可选的寻址方式。如果不开启分页，分段寻址所产生的线性地址直接对应内存中的物理地址。开启分页后，分页寻址将分段产生的线性地址作为输入再通过页目录和页表映射得出最终的物理地址。分页机制的发明实现了段内数据的离散存储，为存储器解决了外部碎片等问题，基于其思想而后出现的请求分页技术，解决了大型软件在有限内存空间中正常运行的难题。






###   4 小结
---

- 本文首先通过物理寻址方式引出 x86处理器虚拟寻址概念，再由分段寻址这种虚拟寻址方式在 x86处理器上的演变过程介绍了处理器的两种工作模式——实模式与保护模式。最后，在保护模式的基础上介绍了 x86处理器分段与分页寻址方式的详细过程。
- 如果有过操作系统学习背景的读者，在看到本文关于分段和分页介绍后，应该会想到虚拟内存的核心实现技术请求分段和请求分页。本文所讲的分段和分页技术正是后者的实现基础，为存储器的虚拟扩容提供了解决方法。








### 参考资料
---
- [Linux内核完全注释，赵炯](https://book.douban.com/subject/1231236/)
- [x86汇编语言：从实模式到保护模式，李忠](https://book.douban.com/subject/20492528//)

